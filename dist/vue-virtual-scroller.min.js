var VueVirtualScroller=function(e){"use strict";var n={itemsLimit:1e3};var t=void 0;function i(){i.init||(i.init=!0,t=-1!==function(){var e=window.navigator.userAgent,n=e.indexOf("MSIE ");if(n>0)return parseInt(e.substring(n+5,e.indexOf(".",n)),10);if(e.indexOf("Trident/")>0){var t=e.indexOf("rv:");return parseInt(e.substring(t+3,e.indexOf(".",t)),10)}var i=e.indexOf("Edge/");return i>0?parseInt(e.substring(i+5,e.indexOf(".",i)),10):-1}())}var s={render:function(){var e=this.$createElement;return(this._self._c||e)("div",{staticClass:"resize-observer",attrs:{tabindex:"-1"}})},staticRenderFns:[],_scopeId:"data-v-b329ee4c",name:"resize-observer",methods:{compareAndNotify:function(){this._w===this.$el.offsetWidth&&this._h===this.$el.offsetHeight||(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.$emit("notify"))},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!t&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),delete this._resizeObject.onload)}},mounted:function(){var e=this;i(),this.$nextTick(function(){e._w=e.$el.offsetWidth,e._h=e.$el.offsetHeight});var n=document.createElement("object");this._resizeObject=n,n.setAttribute("aria-hidden","true"),n.setAttribute("tabindex",-1),n.onload=this.addResizeHandlers,n.type="text/html",t&&this.$el.appendChild(n),n.data="about:blank",t||this.$el.appendChild(n)},beforeDestroy:function(){this.removeResizeHandlers()}};var o={version:"0.4.5",install:function(e){e.component("resize-observer",s),e.component("ResizeObserver",s)}},r=null;"undefined"!=typeof window?r=window.Vue:"undefined"!=typeof global&&(r=global.Vue),r&&r.use(o);var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")},d=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}(),c=function(e){if(Array.isArray(e)){for(var n=0,t=Array(e.length);n<e.length;n++)t[n]=e[n];return t}return Array.from(e)};var u=function(){function e(n,t,i){a(this,e),this.el=n,this.observer=null,this.frozen=!1,this.createObserver(t,i)}return d(e,[{key:"createObserver",value:function(e,n){var t,i,s,o,r,l,a,d=this;(this.observer&&this.destroyObserver(),this.frozen)||(this.options="function"==typeof(t=e)?{callback:t}:t,this.callback=this.options.callback,this.callback&&this.options.throttle&&(this.callback=(i=this.callback,s=this.options.throttle,o=void 0,r=void 0,l=void 0,(a=function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),a=1;a<n;a++)t[a-1]=arguments[a];l=t,o&&e===r||(r=e,clearTimeout(o),o=setTimeout(function(){i.apply(void 0,[e].concat(c(l))),o=0},s))})._clear=function(){clearTimeout(o)},a)),this.oldResult=void 0,this.observer=new IntersectionObserver(function(e){var n=e[0];if(d.callback){var t=n.isIntersecting&&n.intersectionRatio>=d.threshold;if(t===d.oldResult)return;d.oldResult=t,d.callback(t,n),t&&d.options.once&&(d.frozen=!0,d.destroyObserver())}},this.options.intersection),n.context.$nextTick(function(){d.observer.observe(d.el)}))}},{key:"destroyObserver",value:function(){this.observer&&(this.observer.disconnect(),this.observer=null),this.callback&&this.callback._clear&&(this.callback._clear(),this.callback=null)}},{key:"threshold",get:function(){return this.options.intersection&&this.options.intersection.threshold||0}}]),e}();function h(e,n,t){var i=n.value;if("undefined"==typeof IntersectionObserver)console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");else{var s=new u(e,i,t);e._vue_visibilityState=s}}var m={bind:h,update:function(e,n,t){var i=n.value;if(!function e(n,t){if(n===t)return!0;if("object"===(void 0===n?"undefined":l(n))){for(var i in n)if(!e(n[i],t[i]))return!1;return!0}return!1}(i,n.oldValue)){var s=e._vue_visibilityState;s?s.createObserver(i,t):h(e,{value:i},t)}},unbind:function(e){var n=e._vue_visibilityState;n&&(n.destroyObserver(),delete e._vue_visibilityState)}};var f={version:"0.4.3",install:function(e){e.directive("observe-visibility",m)}},p=null;"undefined"!=typeof window?p=window.Vue:"undefined"!=typeof global&&(p=global.Vue),p&&p.use(f);var v="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var g,y=(function(e){var n,t;n=v,t=function(){var e=/(auto|scroll)/,n=function(e,t){return null===e.parentNode?t:n(e.parentNode,t.concat([e]))},t=function(e,n){return getComputedStyle(e,null).getPropertyValue(n)},i=function(n){return e.test(function(e){return t(e,"overflow")+t(e,"overflow-y")+t(e,"overflow-x")}(n))};return function(e){if(e instanceof HTMLElement||e instanceof SVGElement){for(var t=n(e.parentNode,[]),s=0;s<t.length;s+=1)if(i(t[s]))return t[s];return document.scrollingElement||document.documentElement}}},e.exports?e.exports=t():n.Scrollparent=t()}(g={exports:{}},g.exports),g.exports),b=!1;if("undefined"!=typeof window){b=!1;try{var x=Object.defineProperty({},"passive",{get:function(){b=!0}});window.addEventListener("test",null,x)}catch(e){}}var I={components:{ResizeObserver:s},directives:{ObserveVisibility:m},props:{items:{type:Array,required:!0},itemHeight:{type:[Number,String],default:null},minItemHeight:{type:[Number,String],default:null},heightField:{type:String,default:"height"},typeField:{type:String,default:"type"},buffer:{type:[Number,String],default:200},pageMode:{type:Boolean,default:!1},prerender:{type:[Number,String],default:0},emitUpdate:{type:Boolean,default:!1}},computed:{cssClass:function(){return{"page-mode":this.pageMode}},heights:function(){if(null===this.itemHeight){for(var e={"-1":{accumulator:0}},n=this.items,t=this.heightField,i=this.minItemHeight,s=0,o=void 0,r=0,l=n.length;r<l;r++)s+=o=n[r][t]||i,e[r]={accumulator:s,height:o};return e}}},beforeDestroy:function(){this.removeListeners()},methods:{getListenerTarget:function(){var e=y(this.$el);return e===window.document.documentElement&&(e=window),e},getScroll:function(){var e=this.$el,n=void 0;if(this.pageMode){var t=e.getBoundingClientRect(),i=-t.top,s=window.innerHeight;i<0&&(s+=i,i=0),i+s>t.height&&(s=t.height-i),n={top:i,bottom:i+s}}else n={top:e.scrollTop,bottom:e.scrollTop+e.clientHeight};return n},applyPageMode:function(){this.pageMode?this.addListeners():this.removeListeners()},addListeners:function(){this.listenerTarget=this.getListenerTarget(),this.listenerTarget.addEventListener("scroll",this.handleScroll,!!b&&{passive:!0}),this.listenerTarget.addEventListener("resize",this.handleResize)},removeListeners:function(){this.listenerTarget&&(this.listenerTarget.removeEventListener("scroll",this.handleScroll),this.listenerTarget.removeEventListener("resize",this.handleResize),this.listenerTarget=null)},scrollToItem:function(e){var n=void 0;n=null===this.itemHeight?e>0?this.heights[e-1].accumulator:0:e*this.itemHeight,this.scrollToPosition(n)},scrollToPosition:function(e){this.$el.scrollTop=e},itemsLimitError:function(){var e=this;throw setTimeout(function(){console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.","Scroller:",e.$el),console.log("Make sure the scroller has a fixed height and 'overflow-y' set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.")}),new Error("Rendered items limit reached")}}},_={name:"virtual-scroller",mixins:[I],props:{renderers:{default:null},keyField:{type:String,default:"id"},mainTag:{type:String,default:"div"},containerTag:{type:String,default:"div"},containerClass:{default:null},contentTag:{type:String,default:"div"},contentClass:{default:null},poolSize:{type:[Number,String],default:2e3},delayPreviousItems:{type:Boolean,default:!1}},data:function(){return{visibleItems:[],itemContainerStyle:null,itemsStyle:null,keysEnabled:!0,focusedIndex:null}},watch:{items:{handler:function(){this.updateVisibleItems(!0)},deep:!0},pageMode:function(){this.applyPageMode(),this.updateVisibleItems(!0)},itemHeight:"setDirty"},created:function(){this.$_ready=!1,this.$_startIndex=0,this.$_oldScrollTop=null,this.$_oldScrollBottom=null,this.$_offsetTop=0,this.$_height=0,this.$_scrollDirty=!1,this.$_updateDirty=!1;var e=parseInt(this.prerender);e>0?(this.visibleItems=this.items.slice(0,e),this.$_length=this.visibleItems.length,this.$_endIndex=this.$_length-1,this.$_skip=!0):(this.$_endIndex=0,this.$_length=0,this.$_skip=!1)},updated:function(){var e=this;if(this.focusedIndex&&document.activeElement.dataset.index!==this.focusedIndex){var n=Array.from(this.$refs.items.children).find(function(n){return n.dataset.scrollIndex===e.focusedIndex});n&&n.focus()}},mounted:function(){var e=this;this.applyPageMode(),this.$nextTick(function(){e.updateVisibleItems(!0),e.$_ready=!0})},methods:{updateVisibleItems:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.$_updateDirty||(this.$_updateDirty=!0,this.focusedIndex=document.activeElement.dataset.scrollIndex,this.$nextTick(function(){e.$_updateDirty=!1;var t,i,s,o=e.items.length,r=e.getScroll(),l=e.items,a=e.itemHeight,d=void 0,c=void 0;if(r){var u=-1,h=-1,m=parseInt(e.buffer),f=parseInt(e.poolSize),p=~~(r.top/f)*f-m,v=Math.ceil(r.bottom/f)*f+m;if(!n&&(p===e.$_oldScrollTop&&v===e.$_oldScrollBottom||e.$_skip))return void(e.$_skip=!1);if(e.$_oldScrollTop=p,e.$_oldScrollBottom=v,null===a){var g=e.heights,y=0,b=o-1,x=~~(o/2),I=void 0;do{I=x,g[x].accumulator<p?y=x:x<o-1&&g[x+1].accumulator>p&&(b=x),x=~~((y+b)/2)}while(x!==I);for(x<0&&(x=0),u=x,c=x>0?g[x-1].accumulator:0,d=g[o-1].accumulator,h=x;h<o&&g[h].accumulator<v;h++);-1===h?h=l.length-1:++h>o&&(h=o)}else u=~~(p/a),h=Math.ceil(v/a),u<0&&(u=0),h>o&&(h=o),c=u*a,d=o*a;(n||e.$_startIndex!==u||e.$_endIndex!==h||e.$_offsetTop!==c||e.$_height!==d||e.$_length!==o)&&(e.keysEnabled=!(u>e.$_endIndex||h<e.$_startIndex),e.$refs.beforeContent.childElementCount&&(d+=e.$refs.beforeContent.clientHeight),e.itemContainerStyle=(t={height:d+"px"},i="min-height",s=e.$el.parentElement.clientHeight+"px",i in t?Object.defineProperty(t,i,{value:s,enumerable:!0,configurable:!0,writable:!0}):t[i]=s,t),e.itemsStyle={marginTop:c+"px"},e.delayPreviousItems?(e.visibleItems=l.slice(e.$_startIndex,h),e.$nextTick(function(){e.visibleItems=l.slice(u,h)})):e.visibleItems=l.slice(u,h),e.emitUpdate&&e.$emit("update",u,h),e.$_startIndex=u,e.$_endIndex=h,e.$_length=o,e.$_offsetTop=c,e.$_height=d)}}))},setDirty:function(){this.$_oldScrollTop=null,this.$_oldScrollBottom=null},handleScroll:function(){var e=this;this.$_scrollDirty||(this.$_scrollDirty=!0,requestAnimationFrame(function(){e.$_scrollDirty=!1,e.updateVisibleItems()}))},handleResize:function(){this.$emit("resize"),this.$_ready&&this.updateVisibleItems()},handleVisibilityChange:function(e,n){var t=this;this.$_ready&&(e||0!==n.boundingClientRect.width||0!==n.boundingClientRect.height)&&(this.$emit("visible"),this.$nextTick(function(){t.updateVisibleItems()}))},setLastFocused:function(e){this.focusedIndex=e}}};var w=function(e,n,t,i,s,o,r,l,a,d){"boolean"!=typeof r&&(a=l,l=r,r=!1);var c,u="function"==typeof t?t.options:t;if(e&&e.render&&(u.render=e.render,u.staticRenderFns=e.staticRenderFns,u._compiled=!0,s&&(u.functional=!0)),i&&(u._scopeId=i),o?(c=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),n&&n.call(this,a(e)),e&&e._registeredComponents&&e._registeredComponents.add(o)},u._ssrRegister=c):n&&(c=r?function(){n.call(this,d(this.$root.$options.shadowRoot))}:function(e){n.call(this,l(e))}),c)if(u.functional){var h=u.render;u.render=function(e,n){return c.call(n),h(e,n)}}else{var m=u.beforeCreate;u.beforeCreate=m?[].concat(m,c):[c]}return t},$="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());var A=document.head||document.getElementsByTagName("head")[0],S={};var k=function(e){return function(e,n){return function(e,n){var t=$?n.media||"default":e,i=S[t]||(S[t]={ids:new Set,styles:[]});if(!i.ids.has(e)){i.ids.add(e);var s=n.source;if(n.map&&(s+="\n/*# sourceURL="+n.map.sources[0]+" */",s+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n.map))))+" */"),i.element||(i.element=document.createElement("style"),i.element.type="text/css",n.media&&i.element.setAttribute("media",n.media),A.appendChild(i.element)),"styleSheet"in i.element)i.styles.push(s),i.element.styleSheet.cssText=i.styles.filter(Boolean).join("\n");else{var o=i.ids.size-1,r=document.createTextNode(s),l=i.element.childNodes;l[o]&&i.element.removeChild(l[o]),l.length?i.element.insertBefore(r,l[o]):i.element.appendChild(r)}}}(e,n)}},C=_,V=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(e.mainTag,{directives:[{name:"observe-visibility",rawName:"v-observe-visibility",value:e.handleVisibilityChange,expression:"handleVisibilityChange"}],tag:"component",staticClass:"virtual-scroller",class:e.cssClass,on:{"&scroll":function(n){return e.handleScroll(n)}}},[e._t("before-container"),e._v(" "),t(e.containerTag,{ref:"itemContainer",tag:"component",staticClass:"item-container",class:e.containerClass,style:e.itemContainerStyle},[t("div",{ref:"beforeContent"},[e._t("before-content")],2),e._v(" "),t(e.contentTag,{ref:"items",tag:"component",staticClass:"items",class:e.contentClass,style:e.itemsStyle},[e.renderers?e._l(e.visibleItems,function(n,i){return t(e.renderers[n[e.typeField]],{key:e.keysEnabled&&n[e.keyField]||void 0,tag:"component",staticClass:"item",attrs:{item:n,"item-index":e.$_startIndex+i}})}):[e._l(e.visibleItems,function(n,t){return e._t("default",null,{item:n,itemIndex:e.$_startIndex+t,itemKey:e.keysEnabled&&n[e.keyField]||void 0})})]],2),e._v(" "),e._t("after-content")],2),e._v(" "),e._t("after-container"),e._v(" "),t("resize-observer",{on:{notify:e.handleResize}})],2)};V._withStripped=!0;var T=w({render:V,staticRenderFns:[]},function(e){e&&e("data-v-76daa40f_0",{source:"\n.virtual-scroller[data-v-76daa40f]:not(.page-mode) {\n  overflow-y: auto;\n}\n.item-container[data-v-76daa40f] {\n  box-sizing: border-box;\n  width: 100%;\n  overflow: hidden;\n}\n.items[data-v-76daa40f] {\n  width: 100%;\n}\n",map:{version:3,sources:["/home/joao/vue-virtual-scroller/src/components/VirtualScroller.vue"],names:[],mappings:";AAiVA;EACA,gBAAA;AACA;AAEA;EACA,sBAAA;EACA,WAAA;EACA,gBAAA;AACA;AAEA;EACA,WAAA;AACA",file:"VirtualScroller.vue",sourcesContent:['<template>\n  <component\n    :is="mainTag"\n    class="virtual-scroller"\n    :class="cssClass"\n    @scroll.passive="handleScroll"\n    v-observe-visibility="handleVisibilityChange"\n  >\n    <slot\n      name="before-container"\n    />\n\n    <component\n      ref="itemContainer"\n      :is="containerTag"\n      class="item-container"\n      :class="containerClass"\n      :style="itemContainerStyle"\n    >\n      <div ref="beforeContent">\n        <slot\n          name="before-content"\n        />\n      </div>\n      <component\n        ref="items"\n        :is="contentTag"\n        class="items"\n        :class="contentClass"\n        :style="itemsStyle"\n      >\n        <template v-if="renderers">\n          <component\n            class="item"\n            v-for="(item, index) in visibleItems"\n            :key="keysEnabled && item[keyField] || undefined"\n            :is="renderers[item[typeField]]"\n            :item="item"\n            :item-index="$_startIndex + index"\n          />\n        </template>\n        <template v-else>\n          <slot\n            class="item"\n            v-for="(item, index) in visibleItems"\n            :item="item"\n            :item-index="$_startIndex + index"\n            :item-key="keysEnabled && item[keyField] || undefined"\n          />\n        </template>\n      </component>\n      <slot\n        name="after-content"\n      />\n    </component>\n    <slot\n      name="after-container"\n    />\n    <resize-observer @notify="handleResize" />\n  </component>\n</template>\n\n<script>\nimport Scroller from \'../mixins/scroller\'\n\nexport default {\n  name: \'virtual-scroller\',\n\n  mixins: [\n    Scroller,\n  ],\n\n  props: {\n    renderers: {\n      default: null,\n    },\n    keyField: {\n      type: String,\n      default: \'id\',\n    },\n    mainTag: {\n      type: String,\n      default: \'div\',\n    },\n    containerTag: {\n      type: String,\n      default: \'div\',\n    },\n    containerClass: {\n      default: null,\n    },\n    contentTag: {\n      type: String,\n      default: \'div\',\n    },\n    contentClass: {\n      default: null,\n    },\n    poolSize: {\n      type: [Number, String],\n      default: 2000,\n    },\n    delayPreviousItems: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  data () {\n    return {\n      visibleItems: [],\n      itemContainerStyle: null,\n      itemsStyle: null,\n      keysEnabled: true,\n      focusedIndex: null\n    }\n  },\n\n  watch: {\n    items: {\n      handler () {\n        this.updateVisibleItems(true)\n      },\n      deep: true,\n    },\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(true)\n    },\n    itemHeight: \'setDirty\',\n  },\n\n  created () {\n    this.$_ready = false\n    this.$_startIndex = 0\n    this.$_oldScrollTop = null\n    this.$_oldScrollBottom = null\n    this.$_offsetTop = 0\n    this.$_height = 0\n    this.$_scrollDirty = false\n    this.$_updateDirty = false\n\n    const prerender = parseInt(this.prerender)\n    if (prerender > 0) {\n      this.visibleItems = this.items.slice(0, prerender)\n      this.$_length = this.visibleItems.length\n      this.$_endIndex = this.$_length - 1\n      this.$_skip = true\n    } else {\n      this.$_endIndex = 0\n      this.$_length = 0\n      this.$_skip = false\n    }\n  },\n\n  updated () {\n    if (this.focusedIndex) {\n      if (document.activeElement.dataset.index !== this.focusedIndex) {\n        const shouldBeFocused = Array.from(this.$refs.items.children).find(i => i.dataset.scrollIndex === this.focusedIndex)\n        if (shouldBeFocused) {\n          shouldBeFocused.focus()\n        }\n      }\n    }\n  } ,\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      this.updateVisibleItems(true)\n      this.$_ready = true\n    })\n  },\n\n  methods: {\n    updateVisibleItems (force = false) {\n      if (!this.$_updateDirty) {\n        this.$_updateDirty = true\n        this.focusedIndex = document.activeElement.dataset.scrollIndex // str\n\n        this.$nextTick(() => {\n          this.$_updateDirty = false\n\n          const l = this.items.length\n          const scroll = this.getScroll()\n          const items = this.items\n          const itemHeight = this.itemHeight\n          let containerHeight, offsetTop\n          if (scroll) {\n            let startIndex = -1\n            let endIndex = -1\n\n            const buffer = parseInt(this.buffer)\n            const poolSize = parseInt(this.poolSize)\n            const scrollTop = ~~(scroll.top / poolSize) * poolSize - buffer\n            const scrollBottom = Math.ceil(scroll.bottom / poolSize) * poolSize + buffer\n\n            if (!force && ((scrollTop === this.$_oldScrollTop && scrollBottom === this.$_oldScrollBottom) || this.$_skip)) {\n              this.$_skip = false\n              return\n            } else {\n              this.$_oldScrollTop = scrollTop\n              this.$_oldScrollBottom = scrollBottom\n            }\n\n            // Variable height mode\n            if (itemHeight === null) {\n              const heights = this.heights\n              let h\n              let a = 0\n              let b = l - 1\n              let i = ~~(l / 2)\n              let oldI\n\n              // Searching for startIndex\n              do {\n                oldI = i\n                h = heights[i].accumulator\n                if (h < scrollTop) {\n                  a = i\n                } else if (i < l - 1 && heights[i + 1].accumulator > scrollTop) {\n                  b = i\n                }\n                i = ~~((a + b) / 2)\n              } while (i !== oldI)\n              i < 0 && (i = 0)\n              startIndex = i\n\n              // For containers style\n              offsetTop = i > 0 ? heights[i - 1].accumulator : 0\n              containerHeight = heights[l - 1].accumulator\n\n              // Searching for endIndex\n              for (endIndex = i; endIndex < l && heights[endIndex].accumulator < scrollBottom; endIndex++);\n              if (endIndex === -1) {\n                endIndex = items.length - 1\n              } else {\n                endIndex++\n                // Bounds\n                endIndex > l && (endIndex = l)\n              }\n            } else {\n              // Fixed height mode\n              startIndex = ~~(scrollTop / itemHeight)\n              endIndex = Math.ceil(scrollBottom / itemHeight)\n\n              // Bounds\n              startIndex < 0 && (startIndex = 0)\n              endIndex > l && (endIndex = l)\n\n              offsetTop = startIndex * itemHeight\n              containerHeight = l * itemHeight\n            }\n\n            if (\n              force ||\n              this.$_startIndex !== startIndex ||\n              this.$_endIndex !== endIndex ||\n              this.$_offsetTop !== offsetTop ||\n              this.$_height !== containerHeight ||\n              this.$_length !== l\n            ) {\n              this.keysEnabled = !(startIndex > this.$_endIndex || endIndex < this.$_startIndex)\n\n              if (this.$refs.beforeContent.childElementCount) {\n                containerHeight = containerHeight + this.$refs.beforeContent.clientHeight\n              }\n\n              this.itemContainerStyle = {\n                height: containerHeight + \'px\',\n                [\'min-height\']: this.$el.parentElement.clientHeight + \'px\'\n              }\n              this.itemsStyle = {\n                marginTop: offsetTop + \'px\',\n              }\n\n              if (this.delayPreviousItems) {\n                // Add next items\n                this.visibleItems = items.slice(this.$_startIndex, endIndex)\n                // Remove previous items\n                this.$nextTick(() => {\n                  this.visibleItems = items.slice(startIndex, endIndex)\n                })\n              } else {\n                this.visibleItems = items.slice(startIndex, endIndex)\n              }\n\n              this.emitUpdate && this.$emit(\'update\', startIndex, endIndex)\n\n              this.$_startIndex = startIndex\n              this.$_endIndex = endIndex\n              this.$_length = l\n              this.$_offsetTop = offsetTop\n              this.$_height = containerHeight\n            }\n          }\n        })\n      }\n    },\n\n    setDirty () {\n      this.$_oldScrollTop = null\n      this.$_oldScrollBottom = null\n    },\n\n    handleScroll () {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          this.updateVisibleItems()\n        })\n      }\n    },\n\n    handleResize () {\n      this.$emit(\'resize\')\n      this.$_ready && this.updateVisibleItems()\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\n        this.$emit(\'visible\')\n        this.$nextTick(() => {\n          this.updateVisibleItems()\n        })\n      }\n    },\n\n    setLastFocused (index) {\n      this.focusedIndex  = index\n    }\n  },\n}\n<\/script>\n\n<style scoped>\n.virtual-scroller:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.item-container {\n  box-sizing: border-box;\n  width: 100%;\n  overflow: hidden;\n}\n\n.items {\n  width: 100%;\n}\n</style>\n']},media:void 0})},C,"data-v-76daa40f",!1,void 0,k,void 0),E=void 0,H=0,z={name:"RecycleList",mixins:[I],props:{itemHeight:{type:Number,default:null},keyField:{type:String,default:null}},data:function(){return{pool:[],totalHeight:0,rendering:!1}},watch:{items:{handler:function(){this.updateVisibleItems({checkItem:!0})}},pageMode:function(){this.applyPageMode(),this.updateVisibleItems({checkItem:!1})},heights:{handler:function(){this.updateVisibleItems({checkItem:!1})},deep:!0}},created:function(){this.$_ready=!1,this.$_startIndex=0,this.$_endIndex=0,this.$_views=new Map,this.$_unusedViews=new Map,this.$_scrollDirty=!1},mounted:function(){var e=this;this.applyPageMode(),this.$nextTick(function(){e.updateVisibleItems({checkItem:!0}),e.$_ready=!0})},updated:function(){console.log("começando a renderizar"),this.rendering=!1},methods:{addView:function(e,n,t,i,s){var o={item:t,top:0},r={id:H++,index:n,used:!0,key:i,type:s};return Object.defineProperty(o,"nr",{configurable:!1,value:r}),this.rendering=!0,console.log("começando a renderizar"),e.push(o),o},unuseView:function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=this.$_unusedViews,i=e.nr.type,s=t.get(i);s||(s=[],t.set(i,s)),s.push(e),n||(e.nr.used=!1,e.top=-9999,this.$_views.delete(e.nr.key))},handleResize:function(){this.$emit("resize"),this.$_ready&&this.updateVisibleItems({checkItem:!1})},handleScroll:function(e){E.$_scrollDirty||(E.$_scrollDirty=!0,requestAnimationFrame(function(){E.$_scrollDirty=!1,E.a.methods.updateVisibleItems({checkItem:!1}).continuous||(clearTimeout(E.$_refreshTimout),E.$_refreshTimout=setTimeout(E.methods.handleScroll,100))}))},handleVisibilityChange:function(e,n){var t=this;this.$_ready&&(e||0!==n.boundingClientRect.width||0!==n.boundingClientRect.height)&&(this.$emit("visible"),requestAnimationFrame(function(){t.updateVisibleItems({checkItem:!1})}))},updateVisibleItems:function(e){var n=e.checkItem,t=this.getScroll(),i=parseInt(this.buffer);t.top-=i,t.bottom+=i;var s=this.itemHeight,o=this.typeField,r=this.keyField,l=this.items,a=l.length,d=this.heights,c=this.$_views,u=this.$_unusedViews,h=this.pool,m=void 0,f=void 0,p=void 0;if(a)if(null===s){var v=0,g=a-1,y=~~(a/2),b=void 0;do{b=y,d[y].accumulator<t.top?v=y:y<a-1&&d[y+1].accumulator>t.top&&(g=y),y=~~((v+g)/2)}while(y!==b);for(y<0&&(y=0),m=y,p=d[a-1].accumulator,f=y;f<a&&d[f].accumulator<t.bottom;f++);-1===f?f=l.length-1:++f>a&&(f=a)}else m=~~(t.top/s),f=Math.ceil(t.bottom/s),m<0&&(m=0),f>a&&(f=a),p=a*s;else m=f=p=0;this.totalHeight=p;var x=void 0,I=m<=this.$_endIndex&&f>=this.$_startIndex,_=void 0;if(this.$_continuous!==I){if(I){c.clear(),u.clear();for(var w=0,$=h.length;w<$;w++)x=h[w],this.unuseView(x)}this.$_continuous=I}else if(I)for(var A=0,S=h.length;A<S;A++)(x=h[A]).nr.used&&(n&&(x.nr.index=l.findIndex(function(e){return r?e[r]==x.item[r]:e===x.item})),(-1===x.nr.index||x.nr.index<m||x.nr.index>f)&&this.unuseView(x));I||(_=new Map);for(var k=void 0,C=void 0,V=void 0,T=void 0,E=m;E<f;E++){k=l[E];var H=r?k[r]:k;x=c.get(H),s||d[E].height?(x?x.nr.used=!0:(C=k[o],I?(V=u.get(C))&&V.length?((x=V.pop()).item=k,x.nr.used=!0,x.nr.index=E,x.nr.key=H,x.nr.type=C):x=this.addView(h,E,k,H,C):(V=u.get(C),T=_.get(C)||0,V&&T<V.length?((x=V[T]).item=k,x.nr.used=!0,x.nr.index=E,x.nr.key=H,x.nr.type=C,_.set(C,T+1)):(x=this.addView(h,E,k,H,C),this.unuseView(x,!0)),T++),c.set(H,x)),x.top=null===s?d[E-1].accumulator:E*s):x&&this.unuseView(x)}return this.$_startIndex=m,this.$_endIndex=f,this.emitUpdate&&this.$emit("update",m,f),{continuous:I}}}},R=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{directives:[{name:"observe-visibility",rawName:"v-observe-visibility",value:e.handleVisibilityChange,expression:"handleVisibilityChange"}],staticClass:"recycle-list",class:e.cssClass,on:{"&scroll":function(n){return e.handleScroll(n)}}},[t("div",{ref:"wrapper",staticClass:"item-wrapper",style:{height:e.totalHeight+"px"}},e._l(e.pool,function(n,i){return t("div",{key:n.nr.id,staticClass:"item-view",style:{transform:"translateY("+n.top+"px)"}},[e._t("default",null,{item:n.item,index:n.nr.index,active:n.nr.used,poolIndex:i})],2)}),0),e._v(" "),e._t("after-container"),e._v(" "),t("resize-observer",{on:{notify:e.handleResize}})],2)};R._withStripped=!0;var F=w({render:R,staticRenderFns:[]},function(e){e&&e("data-v-7557567e_0",{source:"\n.recycle-list[data-v-7557567e]:not(.page-mode) {\n  overflow-y: auto;\n}\n.item-wrapper[data-v-7557567e] {\n  box-sizing: border-box;\n  width: 100%;\n  overflow: hidden;\n  position: relative;\n}\n.item-view[data-v-7557567e] {\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n",map:{version:3,sources:["/home/joao/vue-virtual-scroller/src/components/RecycleList.vue"],names:[],mappings:";AA0XA;EACA,gBAAA;AACA;AAEA;EACA,sBAAA;EACA,WAAA;EACA,gBAAA;EACA,kBAAA;AACA;AAEA;EACA,WAAA;EACA,kBAAA;EACA,MAAA;EACA,OAAA;EACA,sBAAA;AACA",file:"RecycleList.vue",sourcesContent:['<template>\n  <div\n    class="recycle-list"\n    :class="cssClass"\n    @scroll.passive="handleScroll"\n    v-observe-visibility="handleVisibilityChange"\n  >\n    <div\n      ref="wrapper"\n      class="item-wrapper"\n      :style="{ height: totalHeight + \'px\' }"\n    >\n      <div\n        v-for="(view, poolIndex) of pool"\n        :key="view.nr.id"\n        class="item-view"\n        :style="{ transform: \'translateY(\' + view.top + \'px)\' }"\n      >\n        <slot\n          :item="view.item"\n          :index="view.nr.index"\n          :active="view.nr.used"\n          :poolIndex="poolIndex"\n        />\n      </div>\n    </div>\n\n    <slot\n      name="after-container"\n    />\n\n    <resize-observer @notify="handleResize" />\n  </div>\n</template>\n\n<script>\nimport Scroller from \'../mixins/scroller\'\n\nlet uid = 0\n\nexport default {\n  name: \'RecycleList\',\n\n  mixins: [\n    Scroller,\n  ],\n\n  props: {\n    itemHeight: {\n      type: Number,\n      default: null,\n    },\n    keyField: {\n      type: String,\n      default: null,\n    },\n  },\n\n  data () {\n    return {\n      pool: [],\n      totalHeight: 0,\n      rendering: false\n    }\n  },\n\n  watch: {\n    items: {\n      handler () {\n        this.updateVisibleItems({\n          checkItem: true,\n        })\n      },\n    },\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems({\n        checkItem: false,\n      })\n    },\n    heights: {\n      handler () {\n        this.updateVisibleItems({\n          checkItem: false,\n        })\n      },\n      deep: true,\n    },\n  },\n\n  created () {\n    this.$_ready = false\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n\n    // TODO prerender\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      this.updateVisibleItems({\n        checkItem: true,\n      })\n      this.$_ready = true\n    })\n  },\n\n  updated () {\n    console.log(\'começando a renderizar\')\n    this.rendering = false\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const view = {\n        item,\n        top: 0,\n      }\n      const nonReactive = {\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      }\n      Object.defineProperty(view, \'nr\', {\n        configurable: false,\n        value: nonReactive,\n      })\n      this.rendering = true\n      console.log(\'começando a renderizar\')\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.top = -9999\n        this.$_views.delete(view.nr.key)\n      }\n    },\n\n    handleResize () {\n      this.$emit(\'resize\')\n      this.$_ready && this.updateVisibleItems({\n        checkItem: false,\n      })\n    },\n\n    handleScroll: (event) => {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.a.methods.updateVisibleItems({\n            checkItem: false,\n          })\n\n          // It seems sometimes chrome doesn\'t fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.methods.handleScroll, 100)\n          }\n        })\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\n        this.$emit(\'visible\')\n        requestAnimationFrame(() => {\n          this.updateVisibleItems({\n            checkItem: false,\n          })\n        })\n      }\n    },\n\n    updateVisibleItems ({ checkItem }) {\n      const scroll = this.getScroll()\n      const buffer = parseInt(this.buffer)\n      scroll.top -= buffer\n      scroll.bottom += buffer\n\n      const itemHeight = this.itemHeight\n      const typeField = this.typeField\n      const keyField = this.keyField\n      const items = this.items\n      const count = items.length\n      const heights = this.heights\n      const views = this.$_views\n      let unusedViews = this.$_unusedViews\n      const pool = this.pool\n      let startIndex, endIndex\n      let totalHeight\n\n      if (!count) {\n        startIndex = endIndex = totalHeight = 0\n      } else {\n        // Variable height mode\n        if (itemHeight === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = heights[i].accumulator\n            if (h < scroll.top) {\n              a = i\n            } else if (i < count - 1 && heights[i + 1].accumulator > scroll.top) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalHeight = heights[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && heights[endIndex].accumulator < scroll.bottom; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n        } else {\n          // Fixed height mode\n          startIndex = ~~(scroll.top / itemHeight)\n          endIndex = Math.ceil(scroll.bottom / itemHeight)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n\n          totalHeight = count * itemHeight\n        }\n      }\n\n      this.totalHeight = totalHeight\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n      let unusedIndex\n\n      if (this.$_continuous !== continuous) {\n        if (continuous) {\n          views.clear()\n          unusedViews.clear()\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i]\n            this.unuseView(view)\n          }\n        }\n        this.$_continuous = continuous\n      } else if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) view.nr.index = items.findIndex(\n              item => keyField ? item[keyField] == view.item[keyField] : item === view.item\n            )\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index === -1 ||\n              view.nr.index < startIndex ||\n              view.nr.index > endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      if (!continuous) {\n        unusedIndex = new Map()\n      }\n\n      let item, type, unusedPool\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        view = views.get(key)\n\n        if (!itemHeight && !heights[i].height) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        // No view assigned to item\n        if (!view) {\n          type = item[typeField]\n\n          if (continuous) {\n            unusedPool = unusedViews.get(type)\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n              view.item = item\n              view.nr.used = true\n              view.nr.index = i\n              view.nr.key = key\n              view.nr.type = type\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            unusedPool = unusedViews.get(type)\n            v = unusedIndex.get(type) || 0\n            // Use existing view\n            // We don\'t care if they are already used\n            // because we are not in continous scrolling\n            if (unusedPool && v < unusedPool.length) {\n              view = unusedPool[v]\n              view.item = item\n              view.nr.used = true\n              view.nr.index = i\n              view.nr.key = key\n              view.nr.type = type\n              unusedIndex.set(type, v + 1)\n            } else {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n            }\n            v++\n          }\n          views.set(key, view)\n        } else  {\n          view.nr.used = true\n        }\n\n        // Update position\n        if (itemHeight === null) {\n          view.top = heights[i - 1].accumulator\n        } else {\n          view.top = i * itemHeight\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      this.emitUpdate && this.$emit(\'update\', startIndex, endIndex)\n\n      return {\n        continuous,\n      }\n    },\n  },\n}\n<\/script>\n\n<style scoped>\n.recycle-list:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.item-wrapper {\n  box-sizing: border-box;\n  width: 100%;\n  overflow: hidden;\n  position: relative;\n}\n\n.item-view {\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n</style>\n']},media:void 0})},z,"data-v-7557567e",!1,void 0,k,void 0);var O={version:"0.12.0",install:function(e,t){var i=Object.assign({},{installComponents:!0,componentsPrefix:""},t);for(var s in i)void 0!==i[s]&&(n[s]=i[s]);i.installComponents&&function(e,n){e.component(n+"virtual-scroller",T),e.component(n+"recycle-list",F)}(e,i.componentsPrefix)}},P=null;return"undefined"!=typeof window?P=window.Vue:"undefined"!=typeof global&&(P=global.Vue),P&&P.use(O),e.VirtualScroller=T,e.RecycleList=F,e.default=O,e}({});
